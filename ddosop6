import tkinter as tk
from tkinter import simpledialog, messagebox, scrolledtext
from mcpi.minecraft import Minecraft
import time
import threading
import random
import string

# Global variables
mc = None
running = False
boats_joined = 0

# Function to generate a random name
def generate_random_name():
    return ''.join(random.choices(string.ascii_letters + string.digits, k=8))

# Function to connect to Minecraft
def connect_to_minecraft(ip, port, status_text, chat_text):
    global mc
    try:
        mc = Minecraft.create(ip, port)
        status_text.insert(tk.END, f"Connected to Minecraft server at {ip}:{port}\n")
        start_chat_listener(chat_text)  # Start chat listener thread
        return mc  # Return the Minecraft object
    except Exception as e:
        status_text.insert(tk.END, f"Failed to connect to Minecraft server at {ip}:{port}: {e}\n")
        messagebox.showerror("Error", f"Failed to connect to Minecraft server at {ip}:{port}: {e}")
        return None  # Return None if connection fails

# Function to start listening for chat messages
def start_chat_listener(chat_text):
    global mc
    def listen_for_chat():
        while running:
            chat_messages = mc.events.pollChatPosts()
            for message in chat_messages:
                chat_text.insert(tk.END, f"[{message.entityId}] {message.message}\n")
            time.sleep(0.1)  # Adjust sleep time as needed
    
    threading.Thread(target=listen_for_chat, daemon=True).start()

# Function to find boats
def find_boats(status_text):
    global mc
    try:
        if mc is not None:
            entities = mc.getEntities()
            boats = [entity for entity in entities if entity["type"] == "Boat"]
            return boats
        else:
            status_text.insert(tk.END, "Minecraft connection not established.\n")
            return []
    except Exception as e:
        status_text.insert(tk.END, f"Error finding boats: {e}\n")
        print(f"Error finding boats: {e}")
        return []

# Function to join boats and rename them
def join_boats(boat1, boat2, status_text):
    global boats_joined
    try:
        x1, y1, z1 = boat1["pos"]["x"], boat1["pos"]["y"], boat1["pos"]["z"]
        x2, y2, z2 = boat2["pos"]["x"], boat2["pos"]["y"], boat2["pos"]["z"]

        # Teleport boat1 to boat2 position
        mc.entity.setPos(boat1["id"], x2, y2, z2)
        
        # Rename the boats with random names
        random_name1 = generate_random_name()
        random_name2 = generate_random_name()
        mc.entity.setCustomName(boat1["id"], random_name1)
        mc.entity.setCustomName(boat2["id"], random_name2)
        
        boats_joined += 1
        status_text.insert(tk.END, f"Joined boats: {boats_joined}\n")
    except Exception as e:
        status_text.insert(tk.END, f"Error joining boats: {e}\n")
        print(f"Error joining boats: {e}")

# Function to run the boat joining logic
def run_boat_joining(ip, port, limit, delay_time, status_text):
    global running, boats_joined
    mc = connect_to_minecraft(ip, port, status_text, chat_text)
    if mc is None:
        messagebox.showerror("Error", f"Failed to connect to Minecraft server at {ip}:{port}")
        return
    
    try:
        status_text.insert(tk.END, f"Connected to Minecraft server at {ip}:{port}\n")
        while running and boats_joined < limit:
            boats = find_boats(status_text)
            if boats:
                if len(boats) > 1:
                    join_boats(boats[0], boats[1], status_text)
                else:
                    status_text.insert(tk.END, "Less than 2 boats found. Waiting for more...\n")
            time.sleep(delay_time)
        if boats_joined >= limit:
            status_text.insert(tk.END, f"Boat joining limit of {limit} reached\n")
    except Exception as e:
        status_text.insert(tk.END, f"Error in boat joining process: {e}\n")
        print(f"Error in boat joining process: {e}")

# Function to stop the boat joining process
def stop_script():
    global running
    running = False
    messagebox.showinfo("Info", "Boat joining stopped")

# Function to start the script
def start_script(ip, port, limit, delay):
    global running, boats_joined
    running = True
    boats_joined = 0
    
    # Create main window for status and chat display
    root = tk.Tk()
    root.title("Minecraft Boat Joiner")
    
    # Create scrolled text widget for status updates
    status_text = scrolledtext.ScrolledText(root, width=60, height=10, wrap=tk.WORD)
    status_text.pack(padx=10, pady=10)
    
    # Create label for chat messages
    chat_label = tk.Label(root, text="Server Chat Messages:")
    chat_label.pack()
    
    # Create scrolled text widget for chat messages
    chat_text = scrolledtext.ScrolledText(root, width=60, height=10, wrap=tk.WORD)
    chat_text.pack(padx=10, pady=10)
    
    # Create "Stop" button
    stop_button = tk.Button(root, text="Stop", command=stop_script)
    stop_button.pack(pady=10)
    
    # Create thread to run boat joining logic
    threading.Thread(target=run_boat_joining, args=(ip, port, limit, delay, status_text)).start()
    
    root.mainloop()  # Start the tkinter main loop to keep the window open

# Main function to handle command-line execution
def main():
    # Prompt user for input
    ip = simpledialog.askstring("Input", "Enter Minecraft server IP address:")
    if ip is None:
        return  # User canceled
    
    port = simpledialog.askinteger("Input", "Enter Minecraft server port:")
    if port is None:
        return  # User canceled
    
    limit = simpledialog.askinteger("Input", "Enter boat join limit:")
    if limit is None:
        return  # User canceled
    
    delay = simpledialog.askfloat("Input", "Enter delay time between boat join attempts (seconds):", minvalue=0.1, initialvalue=1.0)
    if delay is None:
        return  # User canceled
    
    # Start the script with user input
    start_script(ip, port, limit, delay)

# Check if the script is run as main module
if __name__ == "__main__":
    main()
